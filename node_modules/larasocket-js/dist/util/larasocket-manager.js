"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LarasocketManager = void 0;
var channel_1 = require("../channel");
var event_formatter_1 = require("./event-formatter");
var outgoing_message_1 = require("./outgoing-message");
var larasocket_websocket_1 = require("./larasocket-websocket");
/**
 * Event name formatter
 */
var LarasocketManager = /** @class */ (function () {
    /**
     * Create a new class instance.
     */
    function LarasocketManager(options) {
        var _this = this;
        /**
         *
         */
        this.subscribedChannels = {};
        this.options = options;
        this.listeners = {};
        this.eventFormatter = new event_formatter_1.EventFormatter(options.namespace);
        this.websocketInstance = new larasocket_websocket_1.LarasocketWebsocket(options, function (d) { return _this.route(d); }, function () { return _this.reconnect(); });
    }
    /**
     *
     */
    LarasocketManager.prototype.disconnect = function () {
        this.websocketInstance.close();
    };
    /**
     * Triggers subscription to each previously subscribed channel.
     */
    LarasocketManager.prototype.reconnect = function () {
        for (var _i = 0, _a = Object.values(this.subscribedChannels); _i < _a.length; _i++) {
            var channel = _a[_i];
            this.subscribe(channel);
        }
    };
    /**
     * Subscribe to a given channel.
     *
     * @param channel
     */
    LarasocketManager.prototype.subscribe = function (channel) {
        var _this = this;
        this.authenticate(channel).then(function (response) {
            _this.subscribedChannels[channel.name] = channel; // track so we can reconnect if needed.
            var subscribeMessage = _this.getSocketMessage(outgoing_message_1.OutgoingMessageType.SUBSCRIBE);
            subscribeMessage.payload = response;
            subscribeMessage.channel = channel;
            _this.send(subscribeMessage);
        });
    };
    /**
     * Unsubscribe to a given channel.
     *
     * @param channel
     */
    LarasocketManager.prototype.unsubscribe = function (channel) {
        delete this.subscribedChannels[channel.name]; // track so we can reconnect if needed.
        var unsubscribeMessage = this.getSocketMessage(outgoing_message_1.OutgoingMessageType.UNSUBSCRIBE);
        unsubscribeMessage.channel = channel;
        this.send(unsubscribeMessage);
    };
    /**
     * Tie an event listener to an action.
     *
     * @param name
     * @param listener
     */
    LarasocketManager.prototype.on = function (name, listener) {
        var formattedEventName = this.eventFormatter.format(name);
        this.listeners[formattedEventName] = listener;
    };
    /**
     * Tie an event listener to an action.
     *
     * @param name
     */
    LarasocketManager.prototype.removeListener = function (name) {
        var formattedEventName = this.eventFormatter.format(name);
        delete this.listeners[formattedEventName];
    };
    /**
     *
     * @param type
     */
    LarasocketManager.prototype.getSocketMessage = function (type) {
        return new outgoing_message_1.OutgoingMessage(this.options.token, type);
    };
    /**
     *
     * @param message
     */
    LarasocketManager.prototype.send = function (message) {
        this.websocketInstance.send(message);
    };
    /**
     *
     */
    LarasocketManager.prototype.socketId = function () {
        return this.websocketInstance.connectionId;
    };
    /**
     * Routes an incoming massage for processing.
     *
     * @param message
     */
    LarasocketManager.prototype.route = function (message) {
        if (message.event) {
            var formattedEventName = this.eventFormatter.format(message.event);
            if (this.listeners[formattedEventName]) {
                try {
                    var payloadForListeners = message.payload;
                    if (typeof payloadForListeners === 'string') {
                        payloadForListeners = JSON.parse(payloadForListeners);
                    }
                    // convert payload into an object
                    this.listeners[formattedEventName](payloadForListeners);
                }
                catch (e) {
                    throw new Error('Failed to parse incoming message');
                }
            }
        }
    };
    /**
     * Authenticate a channel subscription.
     *
     * @param channel
     */
    LarasocketManager.prototype.authenticate = function (channel) {
        if (channel instanceof channel_1.LarasocketPresenceChannel || channel instanceof channel_1.LarasocketPrivateChannel) {
            return this.websocketInstance.getAuthNetworkPromise(channel);
        }
        return Promise.resolve(); // dummy Promise. No auth for public channels.
    };
    return LarasocketManager;
}());
exports.LarasocketManager = LarasocketManager;
