"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LarasocketWebsocket = void 0;
var incoming_message_1 = require("./incoming-message");
var link_message_1 = require("./link-message");
/**
 * Event name formatter
 */
var LarasocketWebsocket = /** @class */ (function () {
    /**
     * Create a new class instance.
     */
    function LarasocketWebsocket(options, onMessageListener, onReconnectListener) {
        /**
         *
         */
        this.timeout = 500;
        this.options = options;
        this.csrf = options.auth.headers['X-CSRF-TOKEN'];
        this.uuid = this.uuidv4();
        this.onMessageListener = onMessageListener;
        this.reconnectListener = onReconnectListener;
        this.websocketUrl = options.wsHost || 'ws.larasocket.com';
        this.token = encodeURIComponent(this.options.token);
    }
    /**
     *
     */
    LarasocketWebsocket.prototype.close = function () {
        if (this.websocketInstance) {
            this.websocketInstance.close();
        }
    };
    /**
     * Send string data over the websocket connection.
     *
     * @param message
     */
    LarasocketWebsocket.prototype.send = function (message) {
        var _this = this;
        this.getWebsocketInstance().then(function (socket) {
            message.connectionId = _this.connectionId; // sometimes, we dont have connectionId information until this callback.
            socket.send(JSON.stringify(message.toNetworkJson()));
        });
    };
    /**
     *
     * @param channel
     */
    LarasocketWebsocket.prototype.getAuthNetworkPromise = function (channel) {
        var _this = this;
        return this.getWebsocketInstance().then(function (socket) {
            if (_this.options.authorizer) {
                var authorizer_1 = _this.options.authorizer(channel, _this.options);
                return new Promise(function (resolve, reject) {
                    authorizer_1.authorize(_this.connectionId, function (error, data) {
                        if (error) {
                            return reject(data);
                        }
                        return resolve(data);
                    });
                });
            }
            var networkAgent;
            if (typeof Vue === 'function' && Vue.http) {
                networkAgent = Vue.http;
            }
            if (typeof axios === 'function') {
                networkAgent = axios;
            }
            if (typeof jQuery === 'function') {
                networkAgent = jQuery;
            }
            if (networkAgent) {
                return networkAgent
                    .post(_this.options.authEndpoint, {
                    socket_id: _this.connectionId,
                    channel_name: channel.name,
                    _token: _this.csrf,
                })
                    .then(function (response) {
                    return response.data;
                });
            }
            else {
                return fetch(_this.options.authEndpoint, {
                    method: 'POST',
                    headers: {
                        Accept: 'application/json',
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        socket_id: _this.connectionId,
                        channel_name: channel.name,
                        _token: _this.csrf,
                    }),
                }).then(function (response) {
                    return response.json();
                });
            }
            throw new Error('Need either Vue.http, axios, jQuery, or fetch.');
        });
    };
    /**
     * Return a promise that will resolve the websocket instance.
     */
    LarasocketWebsocket.prototype.getWebsocketInstance = function () {
        if (this.websocketInstance) {
            return Promise.resolve(this.websocketInstance);
        }
        return this.connect();
    };
    /**
     * The connection is ready.
     */
    LarasocketWebsocket.prototype.websocketInstanceReady = function (socket) {
        this.websocketInstance = socket;
        this.websocketInitializationPromise = undefined;
    };
    /**
     * Reset and connect to the websocket.
     */
    LarasocketWebsocket.prototype.reconnect = function () {
        var _this = this;
        this.websocketInitializationPromise = undefined;
        this.websocketInstance = undefined;
        return this.connect().then(function (websocket) {
            _this.reconnectListener(_this);
            return websocket;
        });
    };
    /**
     * Initialize an websocket connection.
     */
    LarasocketWebsocket.prototype.connect = function () {
        var _this = this;
        if (this.websocketInitializationPromise) {
            return this.websocketInitializationPromise;
        }
        this.websocketInitializationPromise = new Promise(function (resolve, reject) {
            var socket = new WebSocket("wss://" + _this.websocketUrl + "?token=" + _this.token + "&uuid=" + _this.uuid);
            // Connection opened
            socket.onopen = function (e) { return _this.onOpen(socket, e); };
            socket.onclose = function (e) { return _this.onClose(e); };
            socket.onerror = function (e) { return _this.onError(e); };
            // Listen for messages
            socket.onmessage = function (event) {
                _this.onMessage(socket, resolve, reject, event);
            };
        });
        return this.websocketInitializationPromise;
    };
    /**
     * Websocket on open event.
     *
     * @param socket
     * @param event
     */
    LarasocketWebsocket.prototype.onOpen = function (socket, event) {
        if (this.options.debug) {
            // tslint:disable-next-line
            console.log("[LARASOCKET DEBUG]: onopen -> ", event);
        }
        // Warning: can't use this.send. we are still in the initialization process.
        socket.send(JSON.stringify(new link_message_1.LinkMessage(this.token, this.uuid).toNetworkJson()));
    };
    /**
     * Websocket on close event. Larasocket will attempt to reconnect.
     *
     * @param event
     */
    LarasocketWebsocket.prototype.onClose = function (event) {
        var _this = this;
        var timeout = this.getTimeout();
        if (this.options.debug) {
            // tslint:disable-next-line
            console.log("[LARASOCKET DEBUG]: onclose -> ", event);
            // tslint:disable-next-line
            console.log("Reconnecting in " + timeout / 1000 + "s");
        }
        if (this.currentTimeout) {
            clearTimeout(this.currentTimeout);
        }
        this.currentTimeout = setTimeout(function () { return _this.reconnect(); }, timeout);
    };
    /**
     * Websocket on error event. Larasocket will close the connection and reconnect.
     *
     * @param event
     */
    LarasocketWebsocket.prototype.onError = function (event) {
        if (this.options.debug) {
            // tslint:disable-next-line
            console.log("[LARASOCKET DEBUG]: onerror -> ", event);
            // tslint:disable-next-line
            console.log("Error encountered. Closing socket.");
        }
        this.close();
    };
    /**
     * Websocket on message event. Routed to the listener after the websocket connection can be linked to Larasocket backend.
     *
     * @param socket
     * @param resolve
     * @param reject
     * @param event
     */
    LarasocketWebsocket.prototype.onMessage = function (socket, resolve, reject, event) {
        if (this.options.debug) {
            // tslint:disable-next-line
            console.log("[LARASOCKET DEBUG]: onmessage -> ", event);
        }
        var rawMessage = event.data;
        try {
            var rawJson = JSON.parse(rawMessage);
            var message = new incoming_message_1.IncomingMessage(rawJson);
            if (message.action === incoming_message_1.IncomingMessageType.LINKED) {
                this.connectionId = message.connectionId;
                this.websocketInstanceReady(socket);
                resolve(socket);
            }
            else {
                this.onMessageListener(message);
            }
        }
        catch (e) {
            reject(e);
        }
    };
    /**
     * Gets the next timeout in milliseconds before the websocket connection should reconnect.
     */
    LarasocketWebsocket.prototype.getTimeout = function () {
        var nextTimeout = Math.min(this.timeout, 10000); // max 10s timeout.
        this.timeout *= 2; // timeout doubles each time.
        return nextTimeout;
    };
    /**
     * Used to link a socket connection to a db connection.
     */
    LarasocketWebsocket.prototype.uuidv4 = function () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            // tslint:disable-next-line
            var r = (Math.random() * 16) | 0;
            // tslint:disable-next-line
            var v = c === 'x' ? r : (r & 0x3) | 0x8;
            return v.toString(16);
        });
    };
    return LarasocketWebsocket;
}());
exports.LarasocketWebsocket = LarasocketWebsocket;
